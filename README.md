# Golang-intro
#Это краткое руководство, по основным особенностям языка Go.

##Оглавление:
- Введение



## Введение

**Основные преимущества:**

- Простой и понятный синтаксис. 
- Статическая типизация. Позволяет избежать ошибок, допущенных по невнимательности, упрощает чтение и понимание кода, делает код однозначным.
- Скорость и компиляция. Скорость у Go в десятки раз быстрее, чем у скриптовых языков, при меньшем потреблении памяти. При этом, компиляция практически мгновенна. Весь проект компилируется в один бинарный файл, без зависимостей. Как говорится, «просто добавь воды». И вам не надо заботиться о памяти, есть сборщик мусора.
- Отход от ООП. В языке нет классов, но есть структуры данных с методами. Наследование заменяется механизмом встраивания. Существуют интерфейсы, которые не нужно явно имплементировать, а лишь достаточно реализовать методы интерфейса.
- Параллелизм. Параллельные вычисления в языке делаются просто, изящно и без головной боли. Горутины (что-то типа потоков) легковесны, потребляют мало памяти.
- Богатая стандартная библиотека. В языке есть все необходимое для веб-разработки и не только. Количество сторонних библиотек постоянно растет. Кроме того, есть возможность использовать библиотеки C и C++.
- Возможность писать в функциональном стиле. В языке есть замыкания (closures) и анонимные функции. Функции являются объектами первого порядка, их можно передавать в качестве аргументов и использовать в качестве типов данных.

## Hello World

```go
package main

import "fmt"

// this is a comment

func main() {
    fmt.Println("Hello World")
}
```

### Типы

| Литерал | Пояснение |
|:-------:|:---------:|
| `&&`    | И         |
| `||`    | Или       |
| `!`     | Не        |

## Переменные

```go
package main

import "fmt"

func main() {
    var x string
    x = "Hello World"
    fmt.Println(x)
}
```

Если мы хотим присвоить значение переменной при её создании, то можем использовать сокращенную запись:

```go
x := "Hello World"
```

Обратите внимание на то что `:` стоит перед `=` и на отсутствие типа. Тип в данном случае указывать необязательно, так как компилятор Go способен определить тип по литералу, которым мы инициализируем переменную. (Тут мы присваиваем строку, поэтому `x` будет иметь тип `string`) Компилятор может определить тип и при использовании `var`:

```go
var x = "Hello World"
```

И так со всеми типами:

```go
x := 5
fmt.Println(x)
```

В общем, желательно всегда использовать краткий вариант написания.

### Области видимости

Функция `f` имеет доступ к переменной `x`. Теперь предположим, что вместо этого мы написали:

```go
func main() {
    var x string = "Hello World"
    fmt.Println(x)
}

func f() {
    fmt.Println(x)
}
```

Если вы попробуете выполнить эту программу, то получите ошибку.

Компилятор говорит вам, что переменная `x` внутри функции `f` не существует. Она существует только внутри функции `main`. Места, где может использоваться переменная x называется областью видимости переменной. Согласно спецификации, «В Go область видимости ограничена блоками».

### Константы

Go также поддерживает константы. Константы — это переменные, чьи значения не могут быть изменены после инициализации. Они создаются таки же образом, как и переменные, только вместо var используется ключевое слово `const`:

```go
package main

import "fmt"

func main() {
    const x string = "Hello World"
    fmt.Println(x)
}
```

Константы — хороший способ использовать определенные значения в программе, без необходимости писать их каждый раз. Например: константа `Pi` из пакета math.

### Определение нескольких переменных

В Go существует еще одно сокращение, на случай, если необходимо определить несколько переменных:

```go
var (
    a = 5
    b = 10
    c = 15
)
```
Используя ключевые слово `var` (или `const`), за которым идут круглые скобки с одной переменной в каждой строке.

## Управление потоком

### For

Оператор `for` даёт возможность повторять список инструкций (блок) определённое количество раз. Давайте перепишем предыдущую программу используя оператор `for`:

```go
package main

import "fmt"

func main() {
    i := 1
    for i <= 10 {
        fmt.Println(i)
        i = i + 1
    }
}
```

Сначала создается переменная `i`, хранящая число, которое нужно вывести на экран. Затем, с помощью ключевого слова `for`, создается цикл, указывается условное выражение, которое может быть `true` или `false`, и, наконец, сам блок для выполнения. 

В других языках программирования существуют разные виды циклов (while, do, until, foreach, …). У Go вид цикла один, но он может использоваться в разных случаях. Предыдущую программу можно так же записать следующим образом:

```go
func main() {
    for i := 1; i <= 10; i++ {
        fmt.Println(i)
    }
}
```

Теперь условное значение включает в себя так-же и две других инструкции, разделенные точкой с запятой. Сначала инициализируется переменная, затем выполняется условное выражение, и в завершение, переменная «инкрементируется». (Добавление 1 к значению переменной является настолько распространённым действием, что для этого существует специальный оператор: `++`. Аналогично, вычитание 1 может быть выполнено с помощью `--`.)

### If 

```go
func main() {
    for i := 1; i <= 10; i++ {
       if i % 2 == 0 {
            fmt.Println(i, "even")
        } else {
            fmt.Println(i, "odd")
        }
    }
}
```
Давайте рассмотрим эту программу:

   * Создать переменную i типа int и присвоить ей значение 1;
   * i больше или равно 10? Да: перейти в блок;
   * остаток от i ÷ 2 равен 0? Нет: переходим к блоку else;
   * вывести i вместе с odd;
   * инкрементировать i (оператор после условия);
   * i больше или равно 10? Да: перейти в блок;
   * остаток от i ÷ 2 равен 0? Да: переходим к блоку if;
   * вывести i вместе с even;
   * …

### Switch

```go
switch i {
case 0: fmt.Println("Zero")
case 1: fmt.Println("One")
case 2: fmt.Println("Two")
case 3: fmt.Println("Three")
case 4: fmt.Println("Four")
case 5: fmt.Println("Five")
default: fmt.Println("Unknown Number")
}
```

## Массивы, срезы, карты

Массив — это нумерованная последовательность элементов одного типа, с фиксированной длинной. В Go они выглядят так:

```go
var x [5]int
```

`x` — это пример массива, состоящего из пяти элементов типа int. Запустим следующую программу:

```go
package main

import "fmt"

func main() {
    var x [5]int
    x[4] = 100
    fmt.Println(x)
}
```

Вы должны увидеть следующее:

```go
[0 0 0 0 100]
```

Пример программы, использующей массивы:

```go
func main() {
    var x [5]float64
    x[0] = 98
    x[1] = 93
    x[2] = 77
    x[3] = 82
    x[4] = 83

    var total float64 = 0
    for i := 0; i < 5; i++ {
        total += x[i]
    }
    fmt.Println(total / 5)
}
```

Эта программа работает, но её всё еще можно улучшить. Во-первых, бросается в глаза следующее: `i < 5` и `total / 5`. Если мы изменим количество оценок с 5 на 6, то придется переписывать код в этих двух местах. Будет лучше использовать длину массива:

```go
var total float64 = 0
for i := 0; i < len(x); i++ {
    total += x[i]
}
fmt.Println(total / float64(len(x)))
```

Другая вещь, которую мы можем изменить в нашей программе это цикл:

```go
var total float64 = 0
for i, value := range x {
    total += value
}
fmt.Println(total / float64(len(x)))
```

В этом цикле `i` представляет текущую позицию в массиве, а `value` будет тем же самым что и `x[i]`. Мы использовали ключевое слово range перед переменной, по которой мы хотим пройтись циклом.

Выполнение этой программы вызовет ошибку. Нельзя указывать переменные, которые не используются. Поэтому нужно написать так:

```go
var total float64 = 0
for _, value := range x {
    total += value
}
fmt.Println(total / float64(len(x)))
```

А еще в Go есть короткая запись для создания массивов:

```go
x := [5]float64{ 98, 93, 77, 82, 83 }
```

Иногда массивы могут оказаться слишком длинными для записи в одну строку, в этом случае Go позволяет записывать их в несколько строк:

```go
x := [5]float64{ 
    98, 
    93, 
    77, 
    82, 
    83,
}
```

Обратите внимание на последнюю `,` после `83`. Она обязательна и позволяет легко удалить элемент из массива просто закомментировав строку:

```go
x := [4]float64{ 
    98, 
    93, 
    77, 
    82, 
    // 83,
}
```

### Срезы

Срез это часть массива. Как и массивы срезы индексируются и имеют длину. В отличии от массивов, их длину можно изменить. Вот пример среза:

```go
var x []float64
```

Единственное отличие объявления среза от объявления массива — отсутствие указания длины в квадратных скобках. В нашем случае `x` будет иметь длину 0.

Срез создается встроенной функцией `make`:

```go
x := make([]float64, 5)
```
Этот код создаст срез, который связан с массивом типа `float64` и длиной `5`. Срезы всегда связаны с каким-нибудь массивом. они не могут стать больше чем массив, а вот меньше — пожалуйста. Функция `make` принимает и третий параметр:

```go
x := make([]float64, 5, 10)
```

`10` — это длина массива, на который указывает срез.

Другой способ создать срез — использовать выражение `[low : high]`:

```go
arr := [5]float64{1,2,3,4,5}
x := arr[0:5]
```

### Карта (Map)

Карта (также известна как ассоциативный массив или словарь) — это неупорядоченная коллекция пар вида ключ-значение. Пример:

```go
var x map[string]int
```

Карта представляется в связке с ключевым словом `map`, следующим за ним типом ключа в скобках и типом значения после скобок. Читается это следующим образом: «`x` это карта `string`-ов для `int`-ов».

Подобно массивам и срезам, к элементам карт можно обратиться с помощью скобок. Запустим следующую программу:

```go
x := make(map[string]int)
x["key"] = 10
fmt.Println(x["key"])
```

Это выглядит очень похоже на массив, но существует несколько различий. Во-первых длина карты (которую мы можем найти так: `len(x)`) может измениться, когда мы добавим новый элемент в него. В самом начале, при создании длина `0`, после `x[1] = 10` она станет равна `1`. Во-вторых, карта не являются последовательностью. В нашем примере у нас есть элемент `x[1]`, в случае массива должен быть и первый элемент `x[0]`, но в картах это не так.

Также мы можем удалить элементы из карты используя встроенную функцию `delete`:

```go
delete(x,1)
```

Давайте посмотрим на пример программы, использующей карты:

```go
package main

import "fmt"

func main() {
    elements := make(map[string]string)
    elements["H"] = "Hydrogen"
    elements["He"] = "Helium"
    elements["Li"] = "Lithium"
    elements["Be"] = "Beryllium"
    elements["B"] = "Boron"
    elements["C"] = "Carbon"
    elements["N"] = "Nitrogen"
    elements["O"] = "Oxygen"
    elements["F"] = "Fluorine"
    elements["Ne"] = "Neon"

    fmt.Println(elements["Li"])
}
```

В данном примере, `elements` это карта, которое представляет 10 первых химических элементов, индексируемых символами. Это очень частый способ использования карт — в качестве словаря, или таблицы. Предположим, мы пытаемся обратимся к не существующему элементу:

```go
fmt.Println(elements["Un"])
```

Если вы выполните это, то ничего не увидите. Технически, карта вернет нулевое значение хранящегося типа (для строк это пустая строка). Несмотря на то, что мы можем проверить нулевое значение с помощью условия (`elements["Un"] == ""`), в Go есть лучший способ сделать это:

```go
name, ok := elements["Un"]
fmt.Println(name, ok)
```

Доступ к элементу карты может вернуть два значения вместо одного. Первое значение это результат запроса, второе говорит был ли запрос успешен. В Go часто встречается такой код:

```go
if name, ok := elements["Un"]; ok {    
    fmt.Println(name, ok)
}
```

Сперва мы пробуем получить значение из карты, а затем, если это удалось, мы выполняем код внутри блока.

Объявления карт можно записывать сокращенно, также как массивы:

```go
elements := map[string]string{
    "H": "Hydrogen",
    "He": "Helium",
    "Li": "Lithium",
    "Be": "Beryllium",
    "B": "Boron",
    "C": "Carbon",
    "N": "Nitrogen",
    "O": "Oxygen",
    "F": "Fluorine",
    "Ne": "Neon",
}
```

Карты часто используются для хранения общей информации. Давайте изменим нашу программу так, чтобы вместо имени элемента хранить какую-нибудь дополнительную информацию о нем. Например, его агрегатное состояние:

```go
func main() {
    elements := map[string]map[string]string{
            "H": map[string]string{
            "name":"Hydrogen", 
            "state":"gas",
        },
        "He": map[string]string{
            "name":"Helium", 
            "state":"gas",
        },
        "Li": map[string]string{
            "name":"Lithium", 
            "state":"solid",
        },
        "Be": map[string]string{
            "name":"Beryllium", 
            "state":"solid",
        },
        "B":  map[string]string{
            "name":"Boron",
            "state":"solid",
        },
        "C":  map[string]string{
            "name":"Carbon",
            "state":"solid",
        },
        "N":  map[string]string{
            "name":"Nitrogen",
            "state":"gas",
        },
        "O":  map[string]string{
            "name":"Oxygen",
            "state":"gas",
        },
        "F":  map[string]string{
            "name":"Fluorine",
            "state":"gas",
        },
        "Ne":  map[string]string{
            "name":"Neon",
            "state":"gas",
        },
    }

    if el, ok := elements["Li"]; ok {    
        fmt.Println(el["name"], el["state"])
    }
}
```

Заметим что тип нашей карты теперь `map[string]map[string]string`. Мы получили карту строк для карты строк

## Функции

```go
func average(xs []float64) float64 {
    panic("Not Implemented")
}
```

Функция начинается с ключевого слова `func`, за которым следует имя функции. Аргументы (входы) определяются как: `имя тип, имя тип, …`. Наша функция имеет один параметр (список оценок), под названием `xs`. За параметром следует возвращаемый тип. В совокупности, аргументы и возвращаемое значение так же известны как сигнатура функции.

Go способен возвращать несколько значений из функции:

```go
func f() (int, int) {
    return 5, 6
}

func main() {
    x, y := f()
}
```

Для этого необходимы три вещи: указать несколько типов возвращаемых значений, разделенных `,`, изменить выражение после return так, чтобы оно содержало несколько значений, разделенных `,` и, наконец, изменить конструкцию присвоения так, чтобы она содержала несколько значений в левой стороне, перед `:=` или `=`.

Возврат нескольких значений часто используется для возврата ошибки вместе с результатом `(x, err := f())`, или логическое значение, говорящее об успешном выполнении `(x, ok := f())`.

### Переменное число аргументов

Существует особая форма записи последнего аргумента в функции Go:

```go
func add(args ...int) int {
    total := 0
    for _, v := range args {
        total += v
    }
    return total
}
func main() {
    fmt.Println(add(1,2,3))
}

### Замыкания

Возможно создавать функции замыкания внутри функций:

```go
func main() {
    add := func(x, y int) int {
        return x + y
    }
    fmt.Println(add(1,1))    
}
```

### Рекурсия

Функция может вызывать сама себя:

```go
func factorial(x uint) uint {
    if x == 0 {
        return 1
    }

    return x * factorial(x-1)
}
```

### Факториал

`factorial` вызывает сам себя, что делает эту функцию рекурсивной. Для того, чтобы лучше понять, как работает эта функция, давайте пройдемся по `factorial(2)`:

   * x == 0? Нет. (x равен 2)
   * Ищем факториал от x - 1. * x == 0? Нет. (x равен 1) * Ищем факториал от 0. * x == 0? Да, возвращаем 1.
      - Возвращаем 1 * 1
   * Возвращаем 2 * 1

Замыкание и рекурсивный вызов — сильные техники программирования, формирующие основу парадигмы, известной как функциональное программирование. Большинство людей находят функциональное программирование более сложным для понимания, чем подход на основе циклов, логических операторов, переменных и простых функций.

### Отложенный вызов, паника и восстановление

В Go есть специальный оператор `defer`, который позволяет отложить вызов указанной функции, до тех пор, пока не завершится текущая. Рассмотрим следующий пример:

```go
package main

import "fmt"

func first() {
    fmt.Println("1st")
}
func second() {
    fmt.Println("2nd")
}
func main() {
    defer second()
    first()
}
```

}

Эта программа выводит `1st`, затем `2nd`. Грубо говоря, `defer` перемещает вызов second в конец функции:

```go
func main() {
    first()
    second()
}
```

`Defer` часто используется в случаях, когда нужно нужно освободить ресурсы после завершения. Например, открывая файл необходимо убедиться, что позже он должен быть закрыт. C `defer` это выглядит так:

```go
f, _ := os.Open(filename)
defer f.Close()
```
### Паника и восстановление 

package main

import "fmt"

```go
func main() {
    defer func() {    
        str := recover()
        fmt.Println(str)
    }()
    panic("PANIC")
}
```

## Указатели

Когда мы вызываем функцию с аргументами, аргументы копируются в функцию:

```go
func zero(x int) {
    x = 0
}
func main() {
    x := 5
    zero(x)
    fmt.Println(x) // x всё еще равен 5
}
```

В этой программе функция `zero` не изменяет оригинальную переменную `x` из функции `main`. Но что если мы хотим её изменить? Один из способов сделать это — использовать специальный тип данных — указатель:

```go
func zero(xPtr *int) {
    *xPtr = 0
}
func main() {
    x := 5
    zero(&x)
    fmt.Println(x) // x is 0
}
```

Указатели указывают (прошу прощения за тавтологию) на участок в памяти, где хранится значение. Используя указатель (`*int`) в функции `zero` мы можем изменить значение оригинальной переменной.

### Операторы `*` и `&`

В Go указатели представлены через оператор `*` (звёздочка), за которым следует тип хранимого значения. В функции `zero xPtr` является указателем на `int`.

`*` также используется для «разыменовывания» указателей. Когда мы пишем `*xPtr = 0`, то читаем это так: «храним `int 0` в памяти, на которую указывает `xPtr`». Если вместо этого мы попробуем написать `xPtr = 0` то получим ошибку компиляции, потому что `xPtr` имеет тип не `int`, а `*int`. Соответственно, ему может быть присвоен только другой `*int`.

Также существует оператор `&`, который используется для получения адреса переменной. `&x` вернет `*int` (указатель на `int`) потому что `x` имеет тип `int`. Теперь мы можем изменять оригинальную переменную. `&x` в функции `main` и `xPtr` в функции `zero` указывают на один и тот же участок в памяти.

### Оператор new




