# Golang-intro
#Это краткое руководство, по основным особенностям языка Go.

##Оглавление:
- Введение



## Введение

**Основные преимущества:**

- Простой и понятный синтаксис. 
- Статическая типизация. Позволяет избежать ошибок, допущенных по невнимательности, упрощает чтение и понимание кода, делает код однозначным.
- Скорость и компиляция. Скорость у Go в десятки раз быстрее, чем у скриптовых языков, при меньшем потреблении памяти. При этом, компиляция практически мгновенна. Весь проект компилируется в один бинарный файл, без зависимостей. Как говорится, «просто добавь воды». И вам не надо заботиться о памяти, есть сборщик мусора.
- Отход от ООП. В языке нет классов, но есть структуры данных с методами. Наследование заменяется механизмом встраивания. Существуют интерфейсы, которые не нужно явно имплементировать, а лишь достаточно реализовать методы интерфейса.
- Параллелизм. Параллельные вычисления в языке делаются просто, изящно и без головной боли. Горутины (что-то типа потоков) легковесны, потребляют мало памяти.
- Богатая стандартная библиотека. В языке есть все необходимое для веб-разработки и не только. Количество сторонних библиотек постоянно растет. Кроме того, есть возможность использовать библиотеки C и C++.
- Возможность писать в функциональном стиле. В языке есть замыкания (closures) и анонимные функции. Функции являются объектами первого порядка, их можно передавать в качестве аргументов и использовать в качестве типов данных.

## Hello World

```go
package main

import "fmt"

// this is a comment

func main() {
    fmt.Println("Hello World")
}
```

### Типы

| Литерал | Пояснение |
|:-------:|:---------:|
| `&&`    | И         |
| `||`    | Или       |
| `!`     | Не        |

## Переменные

```go
package main

import "fmt"

func main() {
    var x string
    x = "Hello World"
    fmt.Println(x)
}
```

Если мы хотим присвоить значение переменной при её создании, то можем использовать сокращенную запись:

```go
x := "Hello World"
```

Обратите внимание на то что `:` стоит перед `=` и на отсутствие типа. Тип в данном случае указывать необязательно, так как компилятор Go способен определить тип по литералу, которым мы инициализируем переменную. (Тут мы присваиваем строку, поэтому `x` будет иметь тип `string`) Компилятор может определить тип и при использовании `var`:

```go
var x = "Hello World"
```

И так со всеми типами:

```go
x := 5
fmt.Println(x)
```

В общем, желательно всегда использовать краткий вариант написания.

### Области видимости

Функция `f` имеет доступ к переменной `x`. Теперь предположим, что вместо этого мы написали:

```go
func main() {
    var x string = "Hello World"
    fmt.Println(x)
}

func f() {
    fmt.Println(x)
}
```

Если вы попробуете выполнить эту программу, то получите ошибку.

Компилятор говорит вам, что переменная `x` внутри функции `f` не существует. Она существует только внутри функции `main`. Места, где может использоваться переменная x называется областью видимости переменной. Согласно спецификации, «В Go область видимости ограничена блоками».

### Константы

Go также поддерживает константы. Константы — это переменные, чьи значения не могут быть изменены после инициализации. Они создаются таки же образом, как и переменные, только вместо var используется ключевое слово `const`:

```go
package main

import "fmt"

func main() {
    const x string = "Hello World"
    fmt.Println(x)
}
```

Константы — хороший способ использовать определенные значения в программе, без необходимости писать их каждый раз. Например: константа `Pi` из пакета math.

### Определение нескольких переменных

В Go существует еще одно сокращение, на случай, если необходимо определить несколько переменных:

```go
var (
    a = 5
    b = 10
    c = 15
)
```
Используя ключевые слово `var` (или `const`), за которым идут круглые скобки с одной переменной в каждой строке.

## Управление потоком

### For

Оператор `for` даёт возможность повторять список инструкций (блок) определённое количество раз. Давайте перепишем предыдущую программу используя оператор `for`:

```go
package main

import "fmt"

func main() {
    i := 1
    for i <= 10 {
        fmt.Println(i)
        i = i + 1
    }
}
```

Сначала создается переменная `i`, хранящая число, которое нужно вывести на экран. Затем, с помощью ключевого слова `for`, создается цикл, указывается условное выражение, которое может быть `true` или `false`, и, наконец, сам блок для выполнения. 

В других языках программирования существуют разные виды циклов (while, do, until, foreach, …). У Go вид цикла один, но он может использоваться в разных случаях. Предыдущую программу можно так же записать следующим образом:

```go
func main() {
    for i := 1; i <= 10; i++ {
        fmt.Println(i)
    }
}
```

Теперь условное значение включает в себя так-же и две других инструкции, разделенные точкой с запятой. Сначала инициализируется переменная, затем выполняется условное выражение, и в завершение, переменная «инкрементируется». (Добавление 1 к значению переменной является настолько распространённым действием, что для этого существует специальный оператор: `++`. Аналогично, вычитание 1 может быть выполнено с помощью `--`.)

### If 

```go
func main() {
    for i := 1; i <= 10; i++ {
       if i % 2 == 0 {
            fmt.Println(i, "even")
        } else {
            fmt.Println(i, "odd")
        }
    }
}
```
Давайте рассмотрим эту программу:

   * Создать переменную i типа int и присвоить ей значение 1;
   * i больше или равно 10? Да: перейти в блок;
   * остаток от i ÷ 2 равен 0? Нет: переходим к блоку else;
   * вывести i вместе с odd;
   * инкрементировать i (оператор после условия);
   * i больше или равно 10? Да: перейти в блок;
   * остаток от i ÷ 2 равен 0? Да: переходим к блоку if;
   * вывести i вместе с even;
   * …

### Switch

```go
switch i {
case 0: fmt.Println("Zero")
case 1: fmt.Println("One")
case 2: fmt.Println("Two")
case 3: fmt.Println("Three")
case 4: fmt.Println("Four")
case 5: fmt.Println("Five")
default: fmt.Println("Unknown Number")
}
```

## Массивы, срезы, карты

Массив — это нумерованная последовательность элементов одного типа, с фиксированной длинной. В Go они выглядят так:

```go
var x [5]int
```

`x` — это пример массива, состоящего из пяти элементов типа int. Запустим следующую программу:

```go
package main

import "fmt"

func main() {
    var x [5]int
    x[4] = 100
    fmt.Println(x)
}
```

Вы должны увидеть следующее:

```go
[0 0 0 0 100]
```

Пример программы, использующей массивы:

```go
func main() {
    var x [5]float64
    x[0] = 98
    x[1] = 93
    x[2] = 77
    x[3] = 82
    x[4] = 83

    var total float64 = 0
    for i := 0; i < 5; i++ {
        total += x[i]
    }
    fmt.Println(total / 5)
}
```

Эта программа работает, но её всё еще можно улучшить. Во-первых, бросается в глаза следующее: `i < 5` и `total / 5`. Если мы изменим количество оценок с 5 на 6, то придется переписывать код в этих двух местах. Будет лучше использовать длину массива:

```go
var total float64 = 0
for i := 0; i < len(x); i++ {
    total += x[i]
}
fmt.Println(total / float64(len(x)))
```

Другая вещь, которую мы можем изменить в нашей программе это цикл:

```go
var total float64 = 0
for i, value := range x {
    total += value
}
fmt.Println(total / float64(len(x)))
```

В этом цикле `i` представляет текущую позицию в массиве, а `value` будет тем же самым что и `x[i]`. Мы использовали ключевое слово range перед переменной, по которой мы хотим пройтись циклом.

Выполнение этой программы вызовет ошибку. Нельзя указывать переменные, которые не используются. Поэтому нужно написать так:

```go
var total float64 = 0
for _, value := range x {
    total += value
}
fmt.Println(total / float64(len(x)))
```

А еще в Go есть короткая запись для создания массивов:

```go
x := [5]float64{ 98, 93, 77, 82, 83 }
```

Иногда массивы могут оказаться слишком длинными для записи в одну строку, в этом случае Go позволяет записывать их в несколько строк:

```go
x := [5]float64{ 
    98, 
    93, 
    77, 
    82, 
    83,
}
```

Обратите внимание на последнюю `,` после `83`. Она обязательна и позволяет легко удалить элемент из массива просто закомментировав строку:

```go
x := [4]float64{ 
    98, 
    93, 
    77, 
    82, 
    // 83,
}
```

### Срезы

Срез это часть массива. Как и массивы срезы индексируются и имеют длину. В отличии от массивов, их длину можно изменить. Вот пример среза:

```go
var x []float64
```

Единственное отличие объявления среза от объявления массива — отсутствие указания длины в квадратных скобках. В нашем случае `x` будет иметь длину 0.

Срез создается встроенной функцией `make`:

```go
x := make([]float64, 5)
```
Этот код создаст срез, который связан с массивом типа `float64` и длиной `5`. Срезы всегда связаны с каким-нибудь массивом. они не могут стать больше чем массив, а вот меньше — пожалуйста. Функция `make` принимает и третий параметр:

```go
x := make([]float64, 5, 10)
```

`10` — это длина массива, на который указывает срез.

Другой способ создать срез — использовать выражение `[low : high]`:

```go
arr := [5]float64{1,2,3,4,5}
x := arr[0:5]
```

### Map (Карта)

Карта (также известна как ассоциативный массив или словарь) — это неупорядоченная коллекция пар вида ключ-значение. Пример:

```go
var x map[string]int
```

Карта представляется в связке с ключевым словом `map`, следующим за ним типом ключа в скобках и типом значения после скобок. Читается это следующим образом: «`x` это карта `string`-ов для `int`-ов».

Подобно массивам и срезам, к элементам карт можно обратиться с помощью скобок. Запустим следующую программу:

```go
x := make(map[string]int)
x["key"] = 10
fmt.Println(x["key"])
```















